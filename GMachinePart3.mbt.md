# G-Machine 3

This article is the third in a series on implementing Haskell's lazy evaluation in MoonBit. In the previous article, we learned how to compile `let` expressions and how to implement basic arithmetic and comparison operations. In this article, we will implement a context-based optimization method and add support for data structures.

## Tracking Context

Let's review how we implemented primitives in the [last tutorial](gmachine-2.md).

```moonbit skip
let compiled_primitives : List[(String, Int, List[Instruction])] = @list.of([
    // Arith
    (
      "add",
      2,
      @list.of([
        Push(1),
        Eval,
        Push(1),
        Eval,
        Add,
        Update(2),
        Pop(2),
        Unwind,
      ]),
    ),
    (
      "sub",
      2,
      @list.of([
        Push(1),
        Eval,
        Push(1),
        Eval,
        Sub,
        Update(2),
        Pop(2),
        Unwind,
      ]),
    ),
    (
      "mul",
      2,
      @list.of([
        Push(1),
        Eval,
        Push(1),
        Eval,
        Mul,
        Update(2),
        Pop(2),
        Unwind,
      ]),
    ),
    ...
```

This implementation introduces many `Eval` instructions, but they are not always necessary. For example:

```clojure
(add 3 (mul 4 5))
```

The two arguments of `add` are already in WHNF (Weak Head Normal Form) before executing `Eval`. Therefore, the `Eval` instructions here are redundant.

One feasible optimization method is to consider the context when compiling expressions. For example, `add` requires its arguments to be evaluated to WHNF, so its arguments are in a strict context during compilation. By doing this, we can identify some expressions that can be safely compiled with strict evaluation (only a subset).

- An expression in a supercombinator definition is in a strict context.

- If `(op e1 e2)` is in a strict context (where `op` is a primitive), then `e1` and `e2` are also in a strict context.

- If `(let (.....) e)` is in a strict context, then `e` is also in a strict context (but the expressions corresponding to the local variables are not, as `e` may not need their results).

We use the `compileE` function to implement compilation in a strict context, ensuring that _the value at the top of the stack is always in WHNF_.

For the default branch, we simply add an `Eval` instruction after the result of `compileC`.

```moonbit skip
    _ => self.compileC(env) + @list.of([Eval])
```

Constants are pushed directly.

```moonbit skip
    Num(n) => @list.of([PushInt(n)])
```

For `let/letrec` expressions, the specially designed `compileLet` and `compileLetrec` become useful. Compiling a `let/letrec` expression in a strict context only requires using `compileE` to compile its main expression.

```moonbit skip
    Let(rec, defs, e) =>
      if rec {
        compileLetrec(RawExpr::compileE, defs, e, env)
      } else {
        compileLet(RawExpr::compileE, defs, e, env)
      }
```

The `if` and `negate` functions, with 3 and 1 arguments respectively, require special handling.

```moonbit skip
    App(App(App(Var("if"), b), e1), e2) => {
      let condition = b.compileE(env)
      let branch1 = e1.compileE(env)
      let branch2 = e2.compileE(env)
      condition + @list.of([Cond(branch1, branch2)])
    }
    App(Var("negate"), e) => e.compileE(env) + @list.of([Neg])
```

Basic binary operations can be handled uniformly through a lookup table. First, construct a hash table called `builtinOpS` to query the corresponding instructions by the name of the primitive.

```moonbit
let builtinOpS : @hashmap.T[String, Instruction] = {
  let table = @hashmap.new(capacity=50)
  table["add"] = Add
  table["mul"] = Mul
  table["sub"] = Sub
  table["div"] = Div
  table["eq"] = Eq
  table["neq"] = Ne
  table["ge"] = Ge
  table["gt"] = Gt
  table["le"] = Le
  table["lt"] = Lt
  table
}
```

The rest of the handling is not much different.

```moonbit skip
    App(App(Var(op), e0), e1) =>
      match builtinOpS.get(op) {
        None => self.compileC(env) + @list.of([Eval])
        Some(instr) => {
          let code1 = e1.compileE(env)
          let code0 = e0.compileE(argOffset(1, env))
          code1 + code0 + @list.of([instr])
        }
      }
```

Are we done? It seems so, but there's another WHNF besides integers: partially applied functions.

A partial application is when the number of arguments is insufficient. This situation is common in higher-order functions, for example:

```clojure
(map (add 1) listofnumbers)
```

Here, `(add 1)` is a partial application.

To ensure that the code generated by the new compilation strategy works correctly, we need to modify the implementation of the `Unwind` instruction for the `NGlobal` branch. When the number of arguments is insufficient and the dump has saved stacks, we should only retain the original redex and restore the stack.

```moonbit skip
    NGlobal(_, n, c) => {
      let k = self.stack.length()
      if k < n {
        match self.dump {
          Empty => abort("Unwinding with too few arguments")
          More((i, s), tail=rest) => {
            // a1 : ...... : ak
            // ||
            // ak : s
            self.stack = self.stack.drop(k - 1) + s
            self.dump = rest
            self.code = i
          }
        }
      } else {
        if n != 0 {
          self.rearrange(n)
        } else {
          self.put_stack(addr)
        }
        self.put_code(c)
      }
    }
```

This context-based strictness analysis technique is useful but cannot do anything with supercombinator calls. Here we briefly introduce a strictness analysis technique based on boolean operations, which can analyze which arguments of a supercombinator call should be compiled using strict mode.

We first define a concept: bottom, which conceptually represents a value that never terminates or causes an exception. For a supercombinator `f a[1] ...... a[n]`, if one argument `a[i]` satisfies `a[i] = bottom`, then `f a[1] .... a[i] .... a[n] = bottom` (other arguments are not bottom). This indicates that no matter how complex the internal control flow of `f` is, it **must** need the result of argument `a[i]` to get the final result. Therefore, a`[i]` should be strictly evaluated.

> If this condition is not met, it does not necessarily mean that the argument is not needed at all; it may be used only in certain branches and its use is determined at runtime. Such an argument is a typical example of one that should be lazily evaluated.

Let's consider bottom as `false` and non-bottom values as `true`. In this way, all functions in coreF can be considered boolean functions. Take `abs` as an example:

```clojure
(defn abs[n]
  (if (lt n 0) (negate n) n))
```

We analyze how to translate it into a boolean function from top to bottom:

- For an expression like `(if x y z)`, x must be evaluated, but only one of `y` or `z` needs to be evaluated. This can be translated into `x and (y or z)`. Taking the example of the function above, if `n` is bottom, then the condition `(lt n 0)` is also bottom, and thus the result of the entire expression is also bottom.

- For primitive expressions, using `and` for all parts is sufficient.

To determine whether a parameter needs to be compiled strictly, you can convert the above condition into a Boolean function: `a[i] = false` implies `f a[1] .... a[i] .... a[n] = false` (with all other parameters being true).

> This is essentially a method of program analysis called "abstract interpretation."

## Custom Data Structures

The data structure type definition in Haskell is similar to the `enum` in MoonBit. However, since CoreF is a simple toy language used to demonstrate lazy evaluation, it does not allow custom data types. The only built-in data structure is the lazy list.

```clojure
(defn take[n l]
  (case l
    [(Nil) Nil]
    [(Cons x xs)
      (if (le n 0)
        Nil
        (Cons x (take (sub n 1) xs)))]))
```

As shown above, you can use the `case` expression for simple pattern matching on lists.

The corresponding graph node for a list is `NConstr(Int, List[Addr])`, which consists of two parts:

- A tag for different value constructors: the tag for `Nil` is 0, and the tag for `Cons` is 1.
- A list of addresses for storing substructures, whose length corresponds to the number of parameters (arity) of a value constructor.

> This graph node structure can be used to implement various data structures, but CoreF does not have a type system. For demonstration purposes, only lazy lists are implemented.

We need to add two instructions, `Split` and `Pack`, to deconstruct and construct lists.

```moonbit
fn GState::pack(self : GState, t : Int, n : Int) -> Unit {
  let addrs = self.stack.take(n)
  self.stack = self.stack.drop(n)
  let addr = self.heap.alloc(NConstr(t, addrs))
  self.put_stack(addr)
}

fn GState::split(self : GState) -> Unit {
  let addr = self.pop1()
  match self.heap[addr] {
    NConstr(_, addrs) =>
      // n == addrs.length()
      self.stack = addrs + self.stack
    _ => panic()
  }
}
```

Additionally, a `CaseJump` instruction is needed to implement the `case` expression.

```moonbit
fn GState::casejump(self : GState, table : List[(Int, List[Instruction])]) -> Unit {
  let addr = self.pop1()
  match self.heap[addr] {
    NConstr(t, _) =>
      match table.lookup(t) {
        None => abort("casejump")
        Some(instrs) => {
          self.code = instrs + self.code
          self.put_stack(addr)
        }
      }
    otherwise => abort("casejump(): addr = \{addr} node = \{otherwise}")
  }
}
```

After adding the above instructions, we need to modify the `compileC` and `compileE` functions. Since the object matched by the `case` expression needs to be evaluated to WHNF, only the `compileE` function can compile it.

```moonbit skip
    App(App(Constructor(tag=1, arity=2), x), xs) =>
      // Cons(x, xs)
      xs.compileC(env) +
      x.compileC(argOffset(1, env)) +
      @list.of([Pack(1, 2)])
    // Nil
    Constructor(tag=0, arity=0) => @list.of([Pack(0, 0)])
```

```moonbit skip
    Case(e, alts) =>
      e.compileE(env) + @list.of([CaseJump(compileAlts(alts, env))])
    Constructor(tag=0, arity=0) =>
      // Nil
      @list.of([Pack(0, 0)])
    App(App(Constructor(tag=1, arity=2), x), xs) =>
      // Cons(x, xs)
      xs.compileC(env) +
      x.compileC(argOffset(1, env)) +
      @list.of([Pack(1, 2)])
```

At this point, a new problem arises. Previously, printing the evaluation result only needed to handle simple `NNum` nodes, but `NConstr` nodes have substructures. When the list itself is evaluated to WHNF, its substructures are mostly unevaluated `NApp` nodes. We need to add a `Print` instruction, which will recursively evaluate and write the result into the `output` component of `GState`.

```moonbit
fn GState::gprint(self : GState) -> Unit {
  let addr = self.pop1()
  match self.heap[addr] {
    NNum(n) => {
      self.output.write_string(n.to_string())
      self.output.write_char(' ')
    }
    NConstr(0, Empty) => self.output.write_string("Nil")
    NConstr(1, More(addr1, tail=More(addr2, tail=Empty))) => {
      self.code = @list.of([Instruction::Eval, Print, Eval, Print]) +
        self.code
      self.put_stack(addr2)
      self.put_stack(addr1)
    }
    _ => panic()
  }
}
```

Finally, change the initial code of the G-Machine to:

```moonbit
fn run(codes : List[String]) -> String {
  fn parse_then_compile(code : String) -> (String, Int, List[Instruction]) {
    let tokens = tokenize(code)
    let code = try tokens.parse_sc!() catch {
      ParseError(s) => abort(s)
    } else {
      expr => expr
    }
    let code = code.compileSC()
    return code
  }

  let codes = codes.map(parse_then_compile) + prelude_defs.map(ScDef::compileSC)
  let codes = compiled_primitives + codes
  let (heap, globals) = build_initial_heap(codes)
  let initialState : GState = {
    output: @buffer.new(size_hint=60),
    heap,
    stack: @list.empty(),
    code: @list.of([PushGlobal("main"), Eval, Print]),
    globals,
    stats: 0,
    dump: @list.empty(),
  }
  GState::reify(initialState)
}
```

Now, we can write some classic functional programs using lazy lists, such as the infinite Fibonacci sequence:

```moonbit
test "basic eval" {
  let basic = []
  for kv in programs.iter() {
    let (_, v) = kv
    basic.push(v)
  }
  let basic = @list.from_array(basic)
  let main = "(defn main[] (take 20 fibs))"
  inspect!(
    run(basic.prepend(main)),
    content="0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 Nil",
  )
}
```

After introducing data structures, strictness analysis becomes more complex. For lazy lists, there are various evaluation modes:

- Fully strict (requires the list to be finite and all elements to be non-bottom).
- Fully lazy.
- Head strict (the list can be infinite, but its elements cannot be bottom).
- Tail strict (the list must be finite, but its elements can be bottom).

Moreover, the context in which a function is used can change the evaluation mode of its parameters (it cannot be analyzed in isolation and requires cross-function analysis). Such complex strictness analysis usually employs projection analysis techniques. Relevant literature includes:

- Projections for Strictness Analysis

- Static Analysis and Code Optimizations in Glasgow Haskell Compiler

- Implementing Projection-based Strictness Analysis

- Theory and Practice of Demand Analysis in Haskell

## Epilogue

Lazy evaluation can reduce runtime redundant calculations, but it also introduces new problems, such as:

- The notorious side effect order issue.

- Excessive redundant nodes. Some computations that are not shared still store their results on the heap, which is detrimental to utilizing the CPU's caching mechanism.

The representative of lazy evaluation languages, Haskell, offers a controversial solution to the side effect order problem: Monads. This solution has some value for eagerly evaluated languages as well, but many online tutorials emphasize its mathematical background too much and fail to explain how to use it effectively.

Idris2, Haskell's successor (which is no longer a lazy language), retains Monads and introduces another mechanism for handling side effects: Algebraic Effects.

The Spineless G-Machine designed by SPJ improved the problem of excessive redundant nodes, and its successor, the STG, unified the data layout of different types of nodes.

In addition to improvements in abstract machine models, GHC's optimization of Haskell programs heavily relies on inline-based optimizations and projection analysis-based strictness analysis techniques.

In 2004, several GHC designers discovered that the previous push-enter model, where parameters are pushed onto the stack and then a function is called, was less effective than the eval-apply model, where the responsibility is handed to the caller. They published a paper titled "Making a Fast Curry: Push/Enter vs. Eval/Apply for Higher-order Languages."

In 2007, Simon Marlow found that jump and execute code in the tagless design significantly affected the performance of modern CPU branch predictors. The paper "_Faster laziness using dynamic pointer tagging_" described several solutions.

Lazy purely functional languages have shown many interesting possibilities, but they have also faced much criticism and reflection. Nevertheless, it is undoubtedly an intriguing technology!

## Appendix

```moonbit
typealias @list.T as List

enum RawExpr[T] {
  Var(T)
  Num(Int)
  Constructor(tag~ : Int, arity~ : Int) // tag, arity
  App(RawExpr[T], RawExpr[T])
  Let(Bool, List[(T, RawExpr[T])], RawExpr[T]) // isRec, Defs, Body
  Case(RawExpr[T], List[(Int, List[T], RawExpr[T])])
} derive(Show)

struct ScDef[T] {
  name : String
  args : List[T]
  body : RawExpr[T]
} derive(Show)

fn[T] is_atom(self : RawExpr[T]) -> Bool {
  match self {
    Var(_) => true
    Num(_) => true
    _ => false
  }
}

fn[T] ScDef::new(name : String, args : List[T], body : RawExpr[T]) -> ScDef[T] {
  { name, args, body }
}

let prelude_defs : List[ScDef[String]] = {
  let args : (FixedArray[String]) -> List[String] = @list.of
  let id = ScDef::new("I", args(["x"]), Var("x")) // id x = x
  let k = ScDef::new("K", args(["x", "y"]), Var("x")) // K x y = x
  let k1 = ScDef::new("K1", args(["x", "y"]), Var("y")) // K1 x y = y
  let s = ScDef::new(
    "S",
    args(["f", "g", "x"]),
    App(App(Var("f"), Var("x")), App(Var("g"), Var("x"))),
  ) // S f g x = f x (g x)
  let compose = ScDef::new(
    "compose",
    args(["f", "g", "x"]),
    App(Var("f"), App(Var("g"), Var("x"))),
  ) // compose f g x = f (g x)
  let twice = ScDef::new(
    "twice",
    args(["f"]),
    App(App(Var("compose"), Var("f")), Var("f")),
  ) // twice f = compose f f
  @list.of([id, k, k1, s, compose, twice])
}

enum Token {
  DefFn
  Let
  NIL
  CONS
  Case
  Letrec
  Open(Char) // { [ (
  Close(Char) // } ] )
  Id(String)
  Number(Int)
  EOF
} derive(Eq, Show)

fn between(this : Char, lw : Char, up : Char) -> Bool {
  this >= lw && this <= up
}

fn isDigit(this : Char) -> Bool {
  between(this, '0', '9')
}

fn isAlpha(this : Char) -> Bool {
  between(this, 'A', 'Z') || between(this, 'a', 'z')
}

fn isIdChar(this : Char) -> Bool {
  isAlpha(this) || isDigit(this) || this == '_' || this == '-'
}

fn isWhiteSpace(this : Char) -> Bool {
  this == ' ' || this == '\t' || this == '\n'
}

fn to_number(this : Char) -> Int {
  this.to_int() - 48
}

fn isOpen(this : Char) -> Bool {
  this == '(' || this == '[' || this == '{'
}

fn isClose(this : Char) -> Bool {
  this == ')' || this == ']' || this == '}'
}

struct Tokens {
  tokens : Array[Token]
  mut current : Int
} derive(Show)

fn Tokens::new(tokens : Array[Token]) -> Tokens {
  Tokens::{ tokens, current: 0 }
}

fn Tokens::peek(self : Tokens) -> Token {
  if self.current < self.tokens.length() {
    return self.tokens[self.current]
  } else {
    return EOF
  }
}

type! ParseError String

fn Tokens::next(self : Tokens, loc~ : SourceLoc = _) -> Unit {
  self.current = self.current + 1
  if self.current > self.tokens.length() {
    abort("Tokens::next(): \{loc}")
  }
}

fn Tokens::eat(self : Tokens, tok : Token, loc~ : SourceLoc = _) -> Unit!ParseError {
  let __tok = self.peek()
  // assert tok_ != EOF
  if __tok != tok {
    raise ParseError("\{loc} - Tokens::eat(): expect \{tok} but got \{__tok}")
  } else {
    self.next()
  }
}

fn tokenize(source : String) -> Tokens {
  let tokens : Array[Token] = Array::new(capacity=source.length() / 2)
  let mut current = 0
  let source = source.to_array()
  fn peek() -> Char {
    source[current]
  }

  fn next() -> Unit {
    current = current + 1
  }

  while current < source.length() {
    let ch = peek()
    if isWhiteSpace(ch) {
      next()
      continue
    } else if isDigit(ch) {
      let mut num = to_number(ch)
      next()
      while current < source.length() && isDigit(peek()) {
        num = num * 10 + to_number(peek())
        next()
      }
      tokens.push(Number(num))
      continue
    } else if isOpen(ch) {
      next()
      tokens.push(Open(ch))
      continue
    } else if isClose(ch) {
      next()
      tokens.push(Close(ch))
      continue
    } else if isAlpha(ch) {
      let identifier = @buffer.new(size_hint=42)
      identifier.write_char(ch)
      next()
      while current < source.length() && isIdChar(peek()) {
        identifier.write_char(peek())
        next()
      }
      let identifier = identifier.contents().to_unchecked_string()
      match identifier {
        "let" => tokens.push(Let)
        "letrec" => tokens.push(Letrec)
        "Nil" => tokens.push(NIL)
        "Cons" => tokens.push(CONS)
        "case" => tokens.push(Case)
        "defn" => tokens.push(DefFn)
        _ => tokens.push(Id(identifier))
      }
    } else {
      abort("error : invalid Character '\{ch}' in [\{current}]")
    }
  } else {
    return Tokens::new(tokens)
  }
}

test "tokenize" {
  inspect!(tokenize("").tokens, content="[]")
  inspect!(tokenize("12345678").tokens, content="[Number(12345678)]")
  inspect!(tokenize("1234 5678").tokens, content="[Number(1234), Number(5678)]")
  inspect!(
    tokenize("a0 a_0 a-0").tokens,
    content=
      #|[Id("a0"), Id("a_0"), Id("a-0")]
    ,
  )
  inspect!(
    tokenize("(Cons 0 (Cons 1 Nil))").tokens,
    content="[Open('('), CONS, Number(0), Open('('), CONS, Number(1), NIL, Close(')'), Close(')')]",
  )
}

fn Tokens::parse_num(self : Tokens) -> Int!ParseError {
  match self.peek() {
    Number(n) => {
      self.next()
      return n
    }
    other => raise ParseError("parse_num(): expect a number but got \{other}")
  }
}

fn Tokens::parse_var(self : Tokens) -> String!ParseError {
  match self.peek() {
    Id(s) => {
      self.next()
      return s
    }
    other => raise ParseError("parse_var(): expect a variable but got \{other}")
  }
}

fn Tokens::parse_cons(self : Tokens) -> RawExpr[String]!ParseError {
  match self.peek() {
    CONS => {
      self.next()
      let x = self.parse_expr!()
      let xs = self.parse_expr!()
      return App(App(Constructor(tag=1, arity=2), x), xs)
    }
    other => raise ParseError("parse_cons(): expect Cons but got \{other}")
  }
}

fn Tokens::parse_let(self : Tokens) -> RawExpr[String]!ParseError {
  self.eat!(Let)
  self.eat!(Open('('))
  let defs = self.parse_defs!()
  self.eat!(Close(')'))
  let exp = self.parse_expr!()
  Let(false, defs, exp)
}

fn Tokens::parse_letrec(self : Tokens) -> RawExpr[String]!ParseError {
  self.eat!(Letrec)
  self.eat!(Open('('))
  let defs = self.parse_defs!()
  self.eat!(Close(')'))
  let exp = self.parse_expr!()
  Let(true, defs, exp)
}

fn Tokens::parse_case(self : Tokens) -> RawExpr[String]!ParseError {
  self.eat!(Case)
  let exp = self.parse_expr!()
  let alts = self.parse_alts!()
  Case(exp, alts)
}

fn parse_alts(
  self : Tokens
) -> List[(Int, List[String], RawExpr[String])]!ParseError {
  let acc : List[(Int, List[String], RawExpr[String])] = @list.empty()
  loop self.peek(), acc {
    Open('['), acc => {
      self.next()
      self.eat!(Open('('))
      let (tag, variables) = match self.peek() {
        NIL => {
          self.next()
          (0, @list.empty())
        }
        CONS => {
          self.next()
          let x = self.parse_var!()
          let xs = self.parse_var!()
          (1, @list.of([x, xs]))
        }
        other =>
          raise ParseError("parse_alts(): expect NIL or CONS but got \{other}")
      }
      self.eat!(Close(')'))
      let exp = self.parse_expr!()
      let alt = (tag, variables, exp)
      self.eat!(Close(']'))
      continue self.peek(), acc.prepend(alt)
    }
    _, acc => acc.rev()
  }
}

fn Tokens::parse_defs(self : Tokens) -> List[(String, RawExpr[String])]!ParseError {
  let acc : List[(String, RawExpr[String])] = @list.empty()
  loop self.peek(), acc {
    Open('['), acc => {
      self.next()
      let var = self.parse_var!()
      let value = self.parse_expr!()
      self.eat!(Close(']'))
      continue self.peek(), acc.prepend((var, value))
    }
    _, acc => acc.rev()
  }
}

fn Tokens::parse_apply(self : Tokens) -> RawExpr[String]!ParseError {
  let mut res = self.parse_expr!()
  while self.peek() != Close(')') {
    res = App(res, self.parse_expr!())
  }
  return res
}

fn Tokens::parse_expr(self : Tokens) -> RawExpr[String]!ParseError {
  match self.peek() {
    EOF =>
      raise ParseError(
        "parse_expr() : expect a token but got a empty token stream",
      )
    Number(n) => {
      self.next()
      Num(n)
    }
    Id(s) => {
      self.next()
      Var(s)
    }
    NIL => {
      self.next()
      Constructor(tag=0, arity=0)
    }
    Open('(') => {
      self.next()
      let exp = match self.peek() {
        Let => self.parse_let!()
        Letrec => self.parse_letrec!()
        Case => self.parse_case!()
        CONS => self.parse_cons!()
        Id(_) | Open('(') => self.parse_apply!()
        other =>
          raise ParseError("parse_expr(): cant parse \{other} behind a '('")
      }
      self.eat!(Close(')'))
      return exp
    }
    other => raise ParseError("parse_expr(): cant parse \{other}")
  }
}

fn Tokens::parse_sc(self : Tokens) -> ScDef[String]!ParseError {
  self.eat!(Open('('))
  self.eat!(DefFn)
  let fn_name = self.parse_var!()
  self.eat!(Open('['))
  let args = loop self.peek(), @list.empty() {
    tok, acc =>
      if tok != Close(']') {
        let var = self.parse_var!()
        continue self.peek(), acc.prepend(var)
      } else {
        acc.rev()
      }
  }
  self.eat!(Close(']'))
  let body = self.parse_expr!()
  self.eat!(Close(')'))
  ScDef::{ name: fn_name, args, body }
}

test "parse scdef" {
  let test_ = fn!(s) { ignore(tokenize(s).parse_sc!()) }
  for p in programs {
    let (_, p) = p
    test_!(p)
  }
}

let programs : @hashmap.T[String, String] = {
  let programs = @hashmap.new(capacity=40)
  programs["square"] =
    #| (defn square[x] (mul x x))
  programs["fix"] =
    #| (defn fix[f] (letrec ([x (f x)]) x))
  programs["isNil"] =
    #| (defn isNil[x]
    #|   (case x [(Nil) 1] [(Cons n m) 0]))
  programs["tail"] =
    #| (defn tail[l] (case l [(Cons x xs) xs]))
  programs["fibs"] =
    // fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
    #| (defn fibs[] (Cons 0 (Cons 1 (zipWith add fibs (tail fibs)))))
  programs["take"] =
    #| (defn take[n l]
    #|   (case l
    #|     [(Nil) Nil]
    #|     [(Cons x xs)
    #|        (if (le n 0) Nil (Cons x (take (sub n 1) xs)))]))
  programs["zipWith"] =
    #| (defn zipWith[op l1 l2]
    #|   (case l1
    #|     [(Nil) Nil]
    #|     [(Cons x xs)
    #|       (case l2
    #|         [(Nil) Nil]
    #|         [(Cons y ys) (Cons (op x y) (zipWith op xs ys))])]))
  programs["factorial"] =
    #| (defn factorial[n]
    #|   (if (eq n 0) 1 (mul n (factorial (sub n 1)))))
  programs["abs"] =
    #| (defn abs[n]
    #|   (if (lt n 0) (negate n) n))
  programs["length"] =
    #| (defn length[l]
    #|   (case l
    #|     [(Nil) 0]
    #|     [(Cons x xs) (add 1 (length xs))]))
  programs
}

enum Instruction {
  Unwind
  PushGlobal(String)
  PushInt(Int)
  Push(Int)
  MkApp
  Slide(Int)
  Update(Int)
  Pop(Int)
  Alloc(Int)
  Eval
  Add
  Sub
  Mul
  Div
  Neg
  Eq // ==
  Ne // !=
  Lt // <
  Le // <=
  Gt // >
  Ge // >=
  Cond(List[Instruction], List[Instruction])
  Pack(Int, Int) // tag, arity
  CaseJump(List[(Int, List[Instruction])])
  Split
  Print
} derive(Eq, Show)

// Use the 'type' keyword to encapsulate an address type.
type Addr Int derive(Eq, Show)

// Describe graph nodes with an enumeration type.
enum Node {
  NNum(Int)
  // The application node
  NApp(Addr, Addr)
  // To store the number of parameters and 
  // the corresponding sequence of instructions for a super combinator
  NGlobal(String, Int, List[Instruction])
  // The Indirection node，The key component of implementing lazy evaluation
  NInd(Addr)
  NConstr(Int, List[Addr])
} derive(Eq, Show)

struct GHeap {
  // The heap uses an array, 
  // and the space with None content in the array is available as free memory.
  mut object_count : Int
  memory : Array[Node?]
}

// Allocate heap space for nodes.
fn GHeap::alloc(self : GHeap, node : Node) -> Addr {
  let heap = self
  fn next(n : Int) -> Int {
    (n + 1) % heap.memory.length()
  }

  fn free(i : Int) -> Bool {
    match heap.memory[i] {
      None => true
      _ => false
    }
  }

  let mut i = heap.object_count
  while not(free(i)) {
    i = next(i)
  }
  heap.memory[i] = Some(node)
  heap.object_count = heap.object_count + 1
  return Addr(i)
}

fn GHeap::op_get(self : GHeap, key : Addr) -> Node {
  let Addr(i) = key
  match self.memory[i] {
    Some(node) => node
    None => abort("GHeap::get(): index \{i} was empty")
  }
}

fn GHeap::op_set(self : GHeap, key : Addr, val : Node) -> Unit {
  self.memory[key._] = Some(val)
}

struct GState {
  output : @buffer.T
  mut stack : List[Addr]
  heap : GHeap
  globals : @hashmap.T[String, Addr]
  mut dump : List[(List[Instruction], List[Addr])]
  mut code : List[Instruction]
  mut stats : GStats
}

type GStats Int

fn GState::stat_incr(self : GState) -> Unit {
  self.stats = self.stats._ + 1
}

fn GState::put_stack(self : GState, addr : Addr) -> Unit {
  self.stack = self.stack.prepend(addr)
}

fn GState::put_dump(
  self : GState,
  codes : List[Instruction],
  stack : List[Addr]
) -> Unit {
  self.dump = self.dump.prepend((codes, stack))
}

fn GState::put_code(self : GState, instrs : List[Instruction]) -> Unit {
  self.code = instrs + self.code
}

fn GState::pop1(self : GState) -> Addr {
  match self.stack {
    More(addr, tail=reststack) => {
      self.stack = reststack
      addr
    }
    Empty => abort("pop1(): stack size smaller than 1")
  }
}

// e1 e2 ..... -> (e1, e2) ......
fn GState::pop2(self : GState) -> (Addr, Addr) {
  match self.stack {
    More(addr1, tail=More(addr2, tail=reststack)) => {
      self.stack = reststack
      (addr1, addr2)
    }
    _ => abort("pop2(): stack size smaller than 2")
  }
}

fn GState::push_int(self : GState, num : Int) -> Unit {
  let addr = self.heap.alloc(NNum(num))
  self.put_stack(addr)
}

fn GState::push_global(self : GState, name : String) -> Unit {
  guard self.globals.get(name) is Some(addr) else {
    abort("push_global(): cant find supercombinator \{name}")
  }
  self.put_stack(addr)
}

fn GState::push(self : GState, offset : Int) -> Unit {
  // Push(n) a0 : . . . : an : s
  //     =>  an : a0 : . . . : an : s
  let addr = self.stack.unsafe_nth(offset)
  self.put_stack(addr)
}

fn GState::slide(self : GState, n : Int) -> Unit {
  let addr = self.pop1()
  self.stack = self.stack.drop(n).prepend(addr)
}

fn GState::rearrange(self : GState, n : Int) -> Unit {
  let appnodes = self.stack.take(n)
  let args = appnodes.map(fn(addr) {
    guard self.heap[addr] is NApp(_, arg)
    arg
  })
  self.stack = args + appnodes.drop(n - 1)
}

fn GState::mk_apply(self : GState) -> Unit {
  let (a1, a2) = self.pop2()
  let appaddr = self.heap.alloc(NApp(a1, a2))
  self.put_stack(appaddr)
}

fn GState::update(self : GState, n : Int) -> Unit {
  let addr = self.pop1()
  let dst = self.stack.unsafe_nth(n)
  self.heap[dst] = NInd(addr)
}

fn GState::unwind(self : GState) -> Unit {
  let addr = self.pop1()
  match self.heap[addr] {
    NNum(_) =>
      match self.dump {
        Empty => self.put_stack(addr)
        More((instrs, stack), tail=rest_dump) => {
          self.stack = stack
          self.put_stack(addr)
          self.dump = rest_dump
          self.code = instrs
        }
      }
    NApp(a1, _) => {
      self.put_stack(addr)
      self.put_stack(a1)
      self.put_code(@list.of([Unwind]))
    }
    NGlobal(_, n, c) => {
      let k = self.stack.length()
      if k < n {
        match self.dump {
          Empty => abort("Unwinding with too few arguments")
          More((i, s), tail=rest) => {
            // a1 : ...... : ak
            // ||
            // ak : s
            self.stack = self.stack.drop(k - 1) + s
            self.dump = rest
            self.code = i
          }
        }
      } else {
        if n != 0 {
          self.rearrange(n)
        } else {
          self.put_stack(addr)
        }
        self.put_code(c)
      }
    }
    NInd(a) => {
      self.put_stack(a)
      self.put_code(@list.of([Unwind]))
    }
    NConstr(_, _) =>
      match self.dump {
        Empty => abort("Unwinding with too few arguments")
        More((i, s), tail=rest) => {
          self.dump = rest
          self.stack = s
          self.code = i
          self.put_stack(addr)
        }
      }
  }
}

fn GState::alloc_nodes(self : GState, n : Int) -> Unit {
  let dummynode : Node = NInd(Addr(-1))
  for i = 0; i < n; i = i + 1 {
    let addr = self.heap.alloc(dummynode)
    self.put_stack(addr)
  }
}

fn GState::eval(self : GState) -> Unit {
  let addr = self.pop1()
  self.put_dump(self.code, self.stack)
  self.stack = @list.of([addr])
  self.code = @list.of([Unwind])
}

fn GState::condition(
  self : GState,
  i1 : List[Instruction],
  i2 : List[Instruction]
) -> Unit {
  let addr = self.pop1()
  match self.heap[addr] {
    NNum(0) =>
      // false
      self.code = i2 + self.code
    NNum(1) =>
      // true
      self.code = i1 + self.code
    otherwise => abort("cond : \{addr} = \{otherwise}")
  }
}

fn GState::negate(self : GState) -> Unit {
  let addr = self.pop1()
  match self.heap[addr] {
    NNum(n) => {
      let addr = self.heap.alloc(NNum(-n))
      self.put_stack(addr)
    }
    otherwise =>
      abort("negate: wrong kind of node \{otherwise}, address \{addr}")
  }
}

fn GState::lift_arith2(self : GState, op : (Int, Int) -> Int) -> Unit {
  let (a1, a2) = self.pop2()
  match (self.heap[a1], self.heap[a2]) {
    (NNum(n1), NNum(n2)) => {
      let newnode = Node::NNum(op(n1, n2))
      let addr = self.heap.alloc(newnode)
      self.put_stack(addr)
    }
    (node1, node2) => abort("liftArith2: \{a1} = \{node1} \{a2} = \{node2}")
  }
}

fn GState::lift_cmp2(self : GState, op : (Int, Int) -> Bool) -> Unit {
  let (a1, a2) = self.pop2()
  match (self.heap[a1], self.heap[a2]) {
    (NNum(n1), NNum(n2)) => {
      let flag = op(n1, n2)
      let newnode = if flag { Node::NNum(1) } else { Node::NNum(0) }
      let addr = self.heap.alloc(newnode)
      self.put_stack(addr)
    }
    (node1, node2) => abort("liftCmp2: \{a1} = \{node1} \{a2} = \{node2}")
  }
}

fn build_initial_heap(
  scdefs : List[(String, Int, List[Instruction])]
) -> (GHeap, @hashmap.T[String, Addr]) {
  let heap = { object_count: 0, memory: Array::make(10000, None) }
  let globals = @hashmap.new(capacity=50)
  loop scdefs {
    Empty => ()
    More((name, arity, instrs), tail=rest) => {
      let addr = heap.alloc(NGlobal(name, arity, instrs))
      globals[name] = addr
      continue rest
    }
  }
  return (heap, globals)
}

fn GState::step(self : GState) -> Bool {
  match self.code {
    Empty => return false
    More(i, tail=rest) => {
      self.code = rest
      self.stat_incr()
      match i {
        PushGlobal(f) => self.push_global(f)
        PushInt(n) => self.push_int(n)
        Push(n) => self.push(n)
        MkApp => self.mk_apply()
        Unwind => self.unwind()
        Update(n) => self.update(n)
        Pop(n) => self.stack = self.stack.drop(n)
        Alloc(n) => self.alloc_nodes(n)
        Eval => self.eval()
        Slide(n) => self.slide(n)
        Add => self.lift_arith2(fn(x, y) { x + y })
        Sub => self.lift_arith2(fn(x, y) { x - y })
        Mul => self.lift_arith2(fn(x, y) { x * y })
        Div => self.lift_arith2(fn(x, y) { x / y })
        Neg => self.negate()
        Eq => self.lift_cmp2(fn(x, y) { x == y })
        Ne => self.lift_cmp2(fn(x, y) { x != y })
        Lt => self.lift_cmp2(fn(x, y) { x < y })
        Le => self.lift_cmp2(fn(x, y) { x <= y })
        Gt => self.lift_cmp2(fn(x, y) { x > y })
        Ge => self.lift_cmp2(fn(x, y) { x >= y })
        Cond(i1, i2) => self.condition(i1, i2)
        Pack(tag, arity) => self.pack(tag, arity)
        CaseJump(alts) => self.casejump(alts)
        Split => self.split()
        Print => self.gprint()
      }
      return true
    }
  }
}

fn GState::reify(self : GState) -> String {
  if self.step() {
    self.reify()
  } else {
    self.output.contents().to_unchecked_string()
  }
}

fn ScDef::compileSC(self : ScDef[String]) -> (String, Int, List[Instruction]) {
  let name = self.name
  let body = self.body
  let mut arity = 0
  fn gen_env(i : Int, args : List[String]) -> List[(String, Int)] {
    match args {
      Empty => {
        arity = i
        return @list.empty()
      }
      More(s, tail=ss) => gen_env(i + 1, ss).prepend((s, i))
    }
  }

  let env = gen_env(0, self.args)
  (name, arity, body.compileR(env, arity))
}

fn RawExpr::compileR(
  self : RawExpr[String],
  env : List[(String, Int)],
  arity : Int
) -> List[Instruction] {
  if arity == 0 {
    self.compileE(env) + @list.of([Update(arity), Unwind])
  } else {
    self.compileE(env) + @list.of([Update(arity), Pop(arity), Unwind])
  }
}

fn RawExpr::compileC(
  self : RawExpr[String],
  env : List[(String, Int)]
) -> List[Instruction] {
  match self {
    Var(s) =>
      match env.lookup(s) {
        None => @list.of([PushGlobal(s)])
        Some(n) => @list.of([Push(n)])
      }
    Num(n) => @list.of([PushInt(n)])
    App(App(Constructor(tag=1, arity=2), x), xs) =>
      // Cons(x, xs)
      xs.compileC(env) +
      x.compileC(argOffset(1, env)) +
      @list.of([Pack(1, 2)])
    // Nil
    Constructor(tag=0, arity=0) => @list.of([Pack(0, 0)])
    App(e1, e2) =>
      e2.compileC(env) +
      e1.compileC(argOffset(1, env)) +
      @list.of([MkApp])
    Let(rec, defs, e) =>
      if rec {
        compileLetrec(RawExpr::compileC, defs, e, env)
      } else {
        compileLet(RawExpr::compileC, defs, e, env)
      }
    _ => abort("not support yet")
  }
}

fn RawExpr::compileE(
  self : RawExpr[String],
  env : List[(String, Int)]
) -> List[Instruction] {
  match self {
    Num(n) => @list.of([PushInt(n)])
    Let(rec, defs, e) =>
      if rec {
        compileLetrec(RawExpr::compileE, defs, e, env)
      } else {
        compileLet(RawExpr::compileE, defs, e, env)
      }
    App(App(App(Var("if"), b), e1), e2) => {
      let condition = b.compileE(env)
      let branch1 = e1.compileE(env)
      let branch2 = e2.compileE(env)
      condition + @list.of([Cond(branch1, branch2)])
    }
    App(Var("negate"), e) => e.compileE(env) + @list.of([Neg])
    App(App(Var(op), e0), e1) =>
      match builtinOpS.get(op) {
        None => self.compileC(env) + @list.of([Eval])
        Some(instr) => {
          let code1 = e1.compileE(env)
          let code0 = e0.compileE(argOffset(1, env))
          code1 + code0 + @list.of([instr])
        }
      }
    Case(e, alts) =>
      e.compileE(env) + @list.of([CaseJump(compileAlts(alts, env))])
    Constructor(tag=0, arity=0) =>
      // Nil
      @list.of([Pack(0, 0)])
    App(App(Constructor(tag=1, arity=2), x), xs) =>
      // Cons(x, xs)
      xs.compileC(env) +
      x.compileC(argOffset(1, env)) +
      @list.of([Pack(1, 2)])
    _ => self.compileC(env) + @list.of([Eval])
  }
}

fn compileAlts(
  alts : List[(Int, List[String], RawExpr[String])],
  env : List[(String, Int)]
) -> List[(Int, List[Instruction])] {
  fn buildenv(variables : List[String], off : Int) -> List[(String, Int)] {
    match variables {
      Empty => @list.empty()
      More(v, tail=vs) => buildenv(vs, off + 1).prepend((v, off))
    }
  }

  fn go(
    alts : List[(Int, List[String], RawExpr[String])]
  ) -> List[(Int, List[Instruction])] {
    match alts {
      Empty => @list.empty()
      More(alt, tail=rest) => {
        let (tag, variables, body) = alt
        let offset = variables.length()
        let env = buildenv(variables, 0) + argOffset(offset, env)
        let code = @list.of([Split]) +
          body.compileE(env) +
          @list.of([Slide(offset)])
          go(rest).prepend((tag, code))
      }
    }
  }

  go(alts)
}

fn argOffset(n : Int, env : List[(String, Int)]) -> List[(String, Int)] {
  env.map(fn { (name, offset) => (name, offset + n) })
}

fn compileLet(
  comp : (RawExpr[String], List[(String, Int)]) -> List[Instruction],
  defs : List[(String, RawExpr[String])],
  expr : RawExpr[String],
  env : List[(String, Int)]
) -> List[Instruction] {
  let (env, codes) = loop env, @list.empty(), defs {
    env, acc, Empty => (env, acc)
    env, acc, More((name, expr), tail=rest) => {
      let code = expr.compileC(env)
      let env = argOffset(1, env).prepend((name, 0))
      continue env, acc + code, rest
    }
  }
  codes + comp(expr, env) + @list.of([Slide(defs.length())])
}

fn compileLetrec(
  comp : (RawExpr[String], List[(String, Int)]) -> List[Instruction],
  defs : List[(String, RawExpr[String])],
  expr : RawExpr[String],
  env : List[(String, Int)]
) -> List[Instruction] {
  let mut env = env
  loop defs {
    Empty => ()
    More((name, _), tail=rest) => {
      env = argOffset(1, env).prepend((name, 0))
      continue rest
    }
  }
  let n = defs.length()
  fn compileDefs(
    defs : List[(String, RawExpr[String])],
    offset : Int
  ) -> List[Instruction] {
    match defs {
      Empty => comp(expr, env) + @list.of([Slide(n)])
      More((_, expr), tail=rest) =>
        expr.compileC(env) + compileDefs(rest, offset - 1).prepend(Update(offset))
    }
  }
  compileDefs(defs, n - 1).prepend(Alloc(n))
}

let compiled_primitives : List[(String, Int, List[Instruction])] = @list.of([
    // Arith
    (
      "add",
      2,
      @list.of([
        Push(1),
        Eval,
        Push(1),
        Eval,
        Add,
        Update(2),
        Pop(2),
        Unwind,
      ]),
    ),
    (
      "sub",
      2,
      @list.of([
        Push(1),
        Eval,
        Push(1),
        Eval,
        Sub,
        Update(2),
        Pop(2),
        Unwind,
      ]),
    ),
    (
      "mul",
      2,
      @list.of([
        Push(1),
        Eval,
        Push(1),
        Eval,
        Mul,
        Update(2),
        Pop(2),
        Unwind,
      ]),
    ),
    (
      "div",
      2,
      @list.of([
        Push(1),
        Eval,
        Push(1),
        Eval,
        Div,
        Update(2),
        Pop(2),
        Unwind,
      ]),
    ),
    // Compare
    (
      "eq",
      2,
      @list.of([
        Push(1),
        Eval,
        Push(1),
        Eval,
        Eq,
        Update(2),
        Pop(2),
        Unwind,
      ]),
    ),
    (
      "neq",
      2,
      @list.of([
        Push(1),
        Eval,
        Push(1),
        Eval,
        Ne,
        Update(2),
        Pop(2),
        Unwind,
      ]),
    ),
    (
      "ge",
      2,
      @list.of([
        Push(1),
        Eval,
        Push(1),
        Eval,
        Ge,
        Update(2),
        Pop(2),
        Unwind,
      ]),
    ),
    (
      "gt",
      2,
      @list.of([
        Push(1),
        Eval,
        Push(1),
        Eval,
        Gt,
        Update(2),
        Pop(2),
        Unwind,
      ]),
    ),
    (
      "le",
      2,
      @list.of([
        Push(1),
        Eval,
        Push(1),
        Eval,
        Le,
        Update(2),
        Pop(2),
        Unwind,
      ]),
    ),
    (
      "lt",
      2,
      @list.of([
        Push(1),
        Eval,
        Push(1),
        Eval,
        Lt,
        Update(2),
        Pop(2),
        Unwind,
      ]),
    ),
    // MISC
    (
      "negate",
      1,
      @list.of([Push(0), Eval, Neg, Update(1), Pop(1), Unwind]),
    ),
    (
      "if",
      3,
      @list.of([
        Push(0),
        Eval,
        Cond(@list.of([Push(1)]), @list.of([Push(2)])),
        Update(3),
        Pop(3),
        Unwind,
      ]),
    ),
  ],
)
```